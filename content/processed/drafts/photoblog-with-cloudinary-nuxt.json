{
  "frontmatter": {
    "draft": true,
    "dek": "In which we use Cloudinary both as a host and CMS to show photos that we took to our friends",
    "inprogress": true,
    "date": "2022-12-05T23:34:09.000Z",
    "modified": "2024-07-18T18:30:19.000Z",
    "tags": [
      "automation"
    ],
    "hidden": true
  },
  "content": "## Creating a photoblog with Cloudinary and Nuxt\n\n1. I upload files to Cloudinary through automator actions paired with bash scripts\n2. I use the Cloudinary JS SDK to query the most recent photos, EXIF data, and add/remove tags\n3. I use Nuxt to query the API and display the images on my Netlify-hosted website\n\n## Automator Actions\n\n### Automatically uploading screenshots\n\n![The automator configuration that sits outside the following bash scripts: the first is a folder action that passes all green-tagged files/folders, and the other is a folder action that watches the screenshot folder for changes and runs the bash script when a new file is added](http://res.cloudinary.com/ejf/image/upload/v1715186716/Screenshot_2024-05-08_at_12.45.05_PM.png)\n\n```bash\n#!/bin/bash\n\n# API keys for Cloudinary\nexport CLOUDINARY_URL=cloudinary://THIS_IS_SECRET@NAME\n\n# Iterate over each passed argument\nfor file in \"$@\"\ndo\n  # Check if the file exists\n  if [ -f \"$file\" ]; then\n    # Upload to Cloudinary and capture output\n    upload_output=$(/opt/homebrew/bin/cld uploader upload \"$file\" use_filename=true unique_filename=false 2>&1)\n    upload_exit_status=$?\n\n    # Check if the upload was successful\n    if [ $upload_exit_status -eq 0 ]; then\n      # Attempt to extract the URL using the absolute path for jq\n      url=$(echo \"$upload_output\" | /opt/homebrew/bin/jq -r '.url' 2>/dev/null)\n\n      # Check if the URL is non-empty\n      if [ -n \"$url\" ]; then\n        echo \"$url\" | pbcopy\n        # Display success notification with the URL\n        osascript -e \"display notification \\\"Uploaded $file to Cloudinary and URL copied to clipboard: $url\\\" with title \\\"Screenshot Upload\\\"\"\n      else\n        # Display notification for empty URL\n        osascript -e \"display notification \\\"Failed to extract URL from output\\\" with title \\\"Debug\\\"\"\n      fi\n    else\n      # Display notification for upload failure\n      osascript -e \"display notification \\\"Failed to upload $file to Cloudinary. Error: $upload_output\\\" with title \\\"Screenshot Upload\\\"\"\n    fi\n  else\n    # Display notification for file not found\n    osascript -e \"display notification \\\"File does not exist: $file\\\" with title \\\"Debug\\\"\"\n  fi\ndone\n\n```\n\n## Upload all green-tagged files to Cloudinary through Folder Action\n\n```bash\n#!/bin/bash\n\n# Ensure Cloudinary CLI is available\n/opt/homebrew/bin/cld >/dev/null 2>&1 || { echo >&2 \"Cloudinary CLI required but not installed. Aborting.\"; exit 1; }\n\n# API keys for cloudinary\nexport CLOUDINARY_URL=cloudinary://THIS_IS_SECRET@NAME\n\n# Iterate over all green tagged files \nfor folder in \"$@\"\ndo\n  # Find all green tagged files\n  green_files=$(mdfind -onlyin \"$folder\" 'kMDItemUserTags == Green')\n\n  # Count the number of green tagged files\n  num_green_files=$(echo \"$green_files\" | wc -l)\n  osascript -e \"display notification \\\"$num_green_files green files found.\\\" with title \\\"Upload Green Media\\\"\"\n\n  # Initialize counter for successful uploads\n  successful_uploads=0\n\n  # Read each file\n  echo \"$green_files\" | while read -r file\n  do\n    # Check if file is not an empty string\n    if [[ -n \"$file\" ]]\n    then\n      # Use Cloudinary CLI to upload file\n      upload_output=$(/opt/homebrew/bin/cld uploader upload \"$file\" 2>&1)\n\n      if [ $? -eq 0 ]\n      then\n        successful_uploads=$((successful_uploads + 1))\n        # Notify every 25% for less than 10 files, otherwise only on errors\n        if [ $num_green_files -le 10 ] || [ $((successful_uploads % (num_green_files / 4))) -eq 0 ]\n        then\n          osascript -e \"display notification \\\"Uploaded $successful_uploads of $num_green_files files to Cloudinary.\\\" with title \\\"Upload Green Media\\\"\"\n        fi\n      else\n        # Display the error message from Cloudinary in the notification\n        osascript -e \"display notification \\\"Failed to upload $file to Cloudinary. Error: $upload_output\\\" with title \\\"Upload Green Media\\\"\"\n      fi\n    else\n      osascript -e \"display notification \\\"Skipped an empty filename.\\\" with title \\\"Upload Green Media\\\"\"\n    fi\n  done\ndone\n\nosascript -e \"display notification \\\"Done uploading files.\\\" with title \\\"Upload Green Media\\\"\"\n```\n\n\n### Getting EXIF data from a resource\n```js\n// Fetch the resource details with EXIF data\n\nconst result = await cloudinary.api.resource(resourceId, { exif: true });\n```\n\n#### Getting last X photos uploaded\n```js    \n// Fetch the last 100 images uploaded\n    const result = await cloudinary.search\n      .expression(\"resource_type:image\")\n      .sort_by(\"uploaded_at\", \"desc\")\n      .with_field(\"tags\")\n      .max_results(100)\n      .execute();\n```\n#### Nuxt API endpoint: `/server/api/cloudinary.ts`\n```ts\nimport { defineEventHandler } from \"h3\";\nimport { v2 as cloudinary } from \"cloudinary\";\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\n\texport default defineEventHandler(async (event) => {\n\t// readBody is auto-imported by Nuxt from h3\n\tconst body = await readBody(event);\n\tconst numPhotos = +body.numPhotos\n  try {\n    const result = await cloudinary.search\n      .expression(\"resource_type:image\")\n      .sort_by(\"uploaded_at\", \"desc\")\n      .max_results(100) // or numPhotos\n      .execute();\n\n    const photos = result.resources.map((resource) => ({\n      href: resource.secure_url,\n      public_id: resource.public_id,\n      uploaded_at: resource.created_at,\n    }));\n\n    return photos;\n  } catch (err) {\n    console.error(\"Error fetching photos from Cloudinary: \", err);\n    return { error: \"An error occurred while fetching photos.\" };\n  }\n});\n```\n\n\n#### Fetching photos through Nuxt API\n```js\nconst { data: photos } = await useFetch('/api/cloudinary', {\n  method: 'POST',\n  body: JSON.stringify({ numPhotos: numPhotos.value })\n})\n```\n\n#### Adding `photo-blog` tag\n```js\nconst result = await cloudinary.uploader.add_tag('photo-blog', [resourceId]);\n```\n\n\n### All media starts in `~/dump/`\n\nI had a habit of creating new folders for a project, but then not really finishing that, and all of the media would grow cobwebs.\n\n### Apple Shortcuts & Automator\n\nThe first step is getting my files organized on my local computer. This process usually starts with plugging in an SD card from my fujifilm camera, helmet cam, or field audio recorder.\n\n#### Import SD card to `~/dump/`\n\nFirst I use Applescript to show a dialog to ask myself whether to import or not.\n\n```applescript\ndisplay dialog \"New Volume connected- import to ~/dump?\" buttons {\"Yes\", \"No\"} default button 2\n\nif the button returned of the result is \"No\" then\n\nerror number -128 (* user cancelled *)\n\nend if\n```\n\nIf the user selects \"Yes\" we continue on to this shell script\n\n```bash\n#!/bin/bash\n\ntotalFiles=0\ntotalSize=0\n\nhandle_folder() {\n    for aFile in \"$1\"/*; do\n        if [ -d \"$aFile\" ]; then\n            handle_folder \"$aFile\"\n        elif [[ \"$(echo $aFile | tr '[:upper:]' '[:lower:]')\" =~ \\.(jpe?g|mp[34]|raf|wav)$ ]]; then\n            echo \"Copying file $aFile\"  # debugging line\n            newFilePath=$HOME/dump/$(basename \"$aFile\")\n            cp \"$aFile\" \"$newFilePath\"\n                \n            totalFiles=$((totalFiles + 1))\n            totalSize=$((totalSize + $(du -k \"$aFile\" | cut -f1)))\n        fi\n    done\n}\n\nmkdir -p $HOME/dump\n\n# List all volumes and handle each\nfor sdcard in /Volumes/*; do\n    if [ \"$sdcard\" != \"/Volumes/Macintosh HD\" ] && [ -d \"$sdcard\" ]; then  # Exclude Macintosh HD, the main disk of macOS\n        echo \"Handling SD Card: $sdcard\"  # debugging line\n        handle_folder \"$sdcard\"\n    fi\ndone\n\n# Convert size to GB\ntotalSizeGB=$(echo \"scale=2; $totalSize/1024/1024\" | bc)\n\nosascript -e \"display notification \\\"Successfully copied $totalFiles files totaling $totalSizeGB GB to the dump folder\\\" with title \\\"File Operation Summary\\\"\"\n```\n\n#### Organize `~/dump/` into `~/media/`\n\nEvery once in a while, when the folder grows a little too big and unwieldy, I have a shell script as part of a shortcut (which means I can run it from an icon in my dock) that takes everything in `~/dump/` and organizes it into a folder structure by month, day, and media type.\n\nDraft script to move from ~/dump/ into organized folders in ~/media/\n\n```bash\n#!/bin/bash\n\nshopt -s globstar nullglob\n\n# get creation date and format it to YYYY-MM-DD\ngetDate() {\n    date -r \"$1\" +'%Y-%m-%d'\n}\n\n#iterate recursively over all files in the target directory.\nfor file in ~/dump/**/*.*; do\n    # Ensure path is a file\n    if [ -f \"$file\" ]; then\n        #get creation date of file\n        file_date=$(getDate \"$file\")\n\n        #get mime-type of file\n        mime_type=$(file --mime-type -b \"$file\" | awk -F'/' '{print $1}')\n        \n        #needs write permissions on /media/\n        dir_name=~/media/\"$file_date\"/\"$mime_type\"\n\n        #creating Target Directory\n        mkdir -p \"$dir_name\"\n        \n        #move files\n        mv \"$file\" \"$dir_name\"/\n\n        echo \"$file : moved to $dir_name\" >> ~/dump/_logs.txt\n    fi\ndone\n\n#Emptying\nrm -r ~/dump/*\n\n#Logs\necho \"Organizing Completed $(date +\"%T\")\" >> ~/dump/_logs.txt\ncat ~/dump/_logs.txt > ~/logs.txt\n```\n\n#### Upload to the web\n\nThe finder is an extremely powerful way to look at, organize, and tag files. Instead of recreating these things haphazardly in my own media library, I'd rather use one of the best ones in existence and augment it a bit to do my bidding.\n\nI naturally found myself using a system of tagging photos with yellow for \"maybe\" and green for \"publish\". I'd import an SD card for a folder, scroll through it in finder, and slowly gather my picks. Then I'd select all the green files and drag them to another folder, or upload and publish them somewhere. I figured it would be best to try and automate what I was already doing.\n\nSo I created a very basic shortcut that uploads yellow/green files in the current directory to Cloudinary. This also allows you to right-click on a folder and upload all the green-tagged media to Cloudinary.\n\n```bash\n# Navigate to your media directory\ncd ~/media/\n\n# Find all yellow/green tagged files\nfor file in $(mdfind -onlyin . \"kMDItemFSLabel == 2 || kMDItemFSLabel == 6\")\ndo\n  # Upload file to Cloudinary\n  cloudinary upload $file --use_filename --unique_filename false\n  \n  # (Optional) To save the Cloudinary URL in the EXIF data, you would need an additional tool such as ExifTool.\ndone\n```\n\n### Get all Cloudinary photos for a week\n\nNow that all of this content has been stored on Cloudinary, we want a way to get it back out. We are going to need to access the Cloudinary admin, and use our secret, so this has to be done on the server side instead of the client side.\n\nHere's a rough mockup of what we are going to want to do:\n\n```js\nconst cloudinary = require('cloudinary').v2;\n\ncloudinary.config({\n   cloud_name: 'your_cloud_name',\n   api_key: 'your_api_key',\n   api_secret: 'your_api_secret'\n});\n\nasync function getImagesByWeek(year, week) {\n   // Use a library like date-fns to determine the start and end dates of the week\n   const startDate = new Date(dateFns.startOfWeek(new Date(year, 0, 2 + (week - 1) * 7)));\n   const endDate = new Date(dateFns.endOfWeek(new Date(year, 0, 2 + (week - 1) * 7)));\n\n   let expression = `resource_type:image AND creation_date>=${startDate} AND creation_date<=${endDate}`;\n\n   try {\n       let result = await cloudinary.search\n           .expression(expression)\n           .sort_by('upload_date', 'desc')\n           .execute();\n\n       return result.resources;\n   } \n   catch (err) {\n        console.error(err);\n        return [];\n   }\n}\n```\n\nI am creating my gallery as a [Nuxt app] (<https://github.com/ejfox/nuxt-template-2023>) so I think the best way to fetch my new photos is to create them as a [Nuxt Server API](https://nuxt.com/docs/guide/directory-structure/server) so that when I go to `myapp/api/latest-photos` this script will run, fetch the latest photos, add them to the DB if necessary, and return the list so it can be displayed.\n"
}